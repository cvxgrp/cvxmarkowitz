:py:mod:`markowitz.builder`
===========================

.. py:module:: markowitz.builder


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   markowitz.builder._Problem
   markowitz.builder.Builder



Functions
~~~~~~~~~

.. autoapisummary::

   markowitz.builder.deserialize



.. py:function:: deserialize(problem_file: str | bytes | PathLike[str] | PathLike[bytes] | int) -> Any


.. py:class:: _Problem

   .. py:attribute:: problem
      :annotation: :cvxpy.Problem

      

   .. py:attribute:: model
      :annotation: :dict[str, cvx.markowitz.model.Model]

      

   .. py:method:: update(self, **kwargs: cvx.markowitz.types.Matrix) -> _Problem

      Update the problem


   .. py:method:: solve(self, solver: str = cp.ECOS, **kwargs: Any) -> float

      Solve the problem


   .. py:method:: value(self) -> float
      :property:


   .. py:method:: is_dpp(self) -> bool


   .. py:method:: data(self) -> Generator[tuple[tuple[str, str], cvx.markowitz.types.Matrix], None, None]
      :property:


   .. py:method:: parameter(self) -> cvx.markowitz.types.Parameter
      :property:


   .. py:method:: variables(self) -> cvx.markowitz.types.Variables
      :property:


   .. py:method:: weights(self) -> cvx.markowitz.types.Matrix
      :property:


   .. py:method:: factor_weights(self) -> cvx.markowitz.types.Matrix
      :property:


   .. py:method:: serialize(self, problem_file: cvx.markowitz.types.File) -> None



.. py:class:: Builder

   .. py:attribute:: assets
      :annotation: :int = 0

      

   .. py:attribute:: factors
      :annotation: :int | None

      

   .. py:attribute:: model
      :annotation: :dict[str, cvx.markowitz.model.Model]

      

   .. py:attribute:: constraints
      :annotation: :dict[str, cvxpy.Constraint]

      

   .. py:attribute:: variables
      :annotation: :cvx.markowitz.types.Variables

      

   .. py:attribute:: parameter
      :annotation: :cvx.markowitz.types.Parameter

      

   .. py:method:: __post_init__(self) -> None


   .. py:method:: objective(self) -> cvxpy.Expression
      :property:

      Return the objective function


   .. py:method:: build(self) -> _Problem

      Build the cvxpy problem


   .. py:method:: weights(self) -> cvxpy.Variable
      :property:


   .. py:method:: risk(self) -> cvx.markowitz.model.Model
      :property:


   .. py:method:: factor_weights(self) -> cvxpy.Variable
      :property:



